@page "/additional-features"
@inherits PageBase
@using System.Text.Json.Serialization
@using System.Text.RegularExpressions
@using Amazon.BedrockAgent
@using Amazon.BedrockAgent.Model
@using Amazon.BedrockAgentRuntime
@using Amazon.BedrockAgentRuntime.Model
@using Amazon.BedrockRuntime
@using Amazon.GenAI.Abstractions
@using Amazon.GenAI.Abstractions.Bedrock
@using Amazon.GenAI.Abstractions.Message
@using Amazon.GenAI.Components
@using Amazon.GenAI.Models
@using Amazon.Runtime.Internal
@using Amazon.S3
@inject AmazonBedrockAgentClient AgentClient;
@inject AmazonBedrockAgentRuntimeClient AgentRuntimeClient;
@inject AmazonS3Client AmazonS3Client;
@inject AmazonBedrockRuntimeClient BedrockRuntimeClient


<KnowledgeBaseFilter OnFilterUpdated="OnFilterUpdated" Countries="_countries" Cities="_cities"></KnowledgeBaseFilter>

<div class="container-fluid h-100 d-flex flex-column">
    <MessageHistory History="MessageHistory"></MessageHistory>
</div>

<ShortcutPrompts OnPromptChanged="PromptChanged"></ShortcutPrompts>

<div class="input-wrapper">
    <Prompt Model="MessageHistory"
            OnPromptChanged="PromptChanged"
            BuiltinPrompt="@BuiltinPrompt"
            Status="Status">
    </Prompt>
</div>

@code {

    private KnowledgeBaseSummary? _knowledgeBase;
    private List<KnowledgeBaseSummary?>? _knowledgeBases = [];

    AutoConstructedList<RetrievalFilter>? _filters;

    private HashSet<string> _countries = [];
    private HashSet<string> _cities = [];

    protected override async Task OnInitializedAsync()
    {
        await UpdateDropDowns();

        _knowledgeBases = (await AgentClient.ListKnowledgeBasesAsync(new ListKnowledgeBasesRequest())).KnowledgeBaseSummaries
            .OrderBy(x => x.UpdatedAt)
            .Where(x => x.Status.Value.Equals("Active", StringComparison.OrdinalIgnoreCase))
            .ToList();

        _knowledgeBase = _knowledgeBases.FirstOrDefault(x => x != null && 
                                                             x.Name.StartsWith(Constants.KnowledgeBaseName, StringComparison.OrdinalIgnoreCase));

        await base.OnInitializedAsync();
    }

    private async Task PromptChanged(string prompt)
    {
        BuiltinPrompt = prompt;

        if (string.IsNullOrEmpty(prompt)) return;

        Status = Status.Thinking;
        await MessageHistory.AddUserMessage(prompt);

        try
        {
            var request = new RetrieveAndGenerateRequest
                {
                    Input = new RetrieveAndGenerateInput { Text = prompt },
                    RetrieveAndGenerateConfiguration = new RetrieveAndGenerateConfiguration
                    {
                        Type = RetrieveAndGenerateType.KNOWLEDGE_BASE,
                        KnowledgeBaseConfiguration = new KnowledgeBaseRetrieveAndGenerateConfiguration
                        {
                            KnowledgeBaseId = _knowledgeBase?.KnowledgeBaseId,
                            ModelArn = Constants.TextModelId,
                            RetrievalConfiguration = new KnowledgeBaseRetrievalConfiguration
                            {
                                VectorSearchConfiguration = new KnowledgeBaseVectorSearchConfiguration
                                {
                                    OverrideSearchType = "HYBRID"
                                }
                            }
                        }
                    }
                };

            if (_filters is not null)
            {
                request
                    .RetrieveAndGenerateConfiguration
                    .KnowledgeBaseConfiguration
                    .RetrievalConfiguration
                    .VectorSearchConfiguration
                    .Filter = new RetrievalFilter { OrAll = _filters };
            }

            var result = await AgentRuntimeClient!.RetrieveAndGenerateAsync(request);

            var message = await TransformResponseToMessage(result);

            await MessageHistory.AddAiMessage(message);
        }
        catch (AmazonBedrockAgentRuntimeException ex)
        {
            Console.WriteLine($"AWS Error: {ex.Message}");
            throw;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"General Error: {ex.Message}");
            throw;
        }

        await UpdatePage();
    }

    private Task OnFilterUpdated(AutoConstructedList<RetrievalFilter>? filters)
    {
        _filters = filters!.Count == 0 ? null : filters;
        return Task.CompletedTask;
    }

    private async Task UpdateDropDowns()
    {
        try
        {
            var s3Wrapper = new S3Wrapper(AmazonS3Client);
            var attributes = await s3Wrapper.GetMetaDataFromS3(Constants.BucketName, Constants.KnowledgeBaseName, Constants.MetadataExtension);
            foreach (var item in attributes)
            {
                foreach (var dict in item)
                {
                    if (dict.Key.Equals("country", StringComparison.OrdinalIgnoreCase)) _countries.Add(dict.Value);
                    if (dict.Key.Equals("city", StringComparison.OrdinalIgnoreCase)) _cities.Add(dict.Value);
                }
            }
            _countries = _countries.OrderBy(x => x).ToHashSet();
            _cities = _cities.OrderBy(x => x).ToHashSet();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
        }
    }

    private async Task<Message?> TransformResponseToMessage(RetrieveAndGenerateResponse result)
    {
        var message = new Message();
        message = message with { Content = result.Output.Text };
        message = message with { Role = MessageRole.Ai };
        message = message with { DateTime = DateTime.Now };

        if (result.Citations.Count <= 0 || result.Citations[0].RetrievedReferences.Count <= 0) return message;

        var citation = result.Citations[0];

        var originalText = citation.GeneratedResponsePart.TextResponsePart.Text;
        var referenceText = citation.RetrievedReferences[0].Content.Text;

        message = message with { Content = originalText };

        var prompt = $@"
you are a professional reviewer. your only job is to highlight the sentence based on similarities to it's citation.  you can only highlight the sentence once in your response.  if your highlight text, you're not allowed to highlight text again.
here's the text:
'{originalText}'

highlight the text based by wrapping double hash ## around the sentence.  if the citation doesn't appear to be relevant then write ##NOT RELEVANT##

here's the citation::
'{referenceText}'
";

        var bodyJson = AnthropicClaude3.CreateBodyJson(prompt);
        var response = await BedrockRuntimeClient.InvokeModelAsync(Constants.TextModelId, bodyJson).ConfigureAwait(false);
        var responseText = response?["content"]?[0]?["text"]?.GetValue<string>() ?? string.Empty;

        var foundSentence = ExtractTextBetweenHashes(responseText);
        if (foundSentence.Equals("NOT RELEVANT", StringComparison.OrdinalIgnoreCase)) return message;

        var split = SplitSentencesBySentence(originalText, foundSentence);

        var generatedText = $"{split[0]} <a href='#'>[{0 + 1}]</a>";
        generatedText = split.Count > 1 ? $"{generatedText} {split[1]}" : generatedText;

        var image = await GetImageFromTexts(foundSentence, referenceText);

        generatedText = image != null ? $"{generatedText} <img class='citation-img' src='data:image/jpeg;base64,{image.ToBase64()}' />" : generatedText;

        message = message with { Content = generatedText };

        return message;
    }

    private async Task<Data?> GetImageFromTexts(string foundSentence, string referenceText)
    {
        var prompt = $@"
based on the below context create a photorealistic image.
\n\n
'{foundSentence}'\n
...\n
'{referenceText}'
";
        var bodyJson = StableDiffusionImage.CreateBodyJson(prompt);
        var response = await BedrockRuntimeClient.InvokeModelAsync<StableDiffusionSD3Response>(Constants.ImageModelId, bodyJson).ConfigureAwait(false);
        var images = response?.Images.Select(Data.FromBase64).ToList() ?? [];

        return images.FirstOrDefault();
    }

    private static List<string> SplitSentencesBySentence(string originalText, string foundSentence)
    {
        var startIndex = originalText.IndexOf(foundSentence, StringComparison.Ordinal);
        if (startIndex <= 0) return [originalText];

        var firstPart = originalText[..startIndex].Trim();
        var secondPart = originalText[startIndex..].Trim();
        return [firstPart, secondPart];
    }

    static string ExtractTextBetweenHashes(string input)
    {
        const string pattern = @"##([\s\S]*?)##";
        var match = Regex.Match(input, pattern);

        return match.Success ? match.Groups[1].Value : input;
    }

    public class StableDiffusionSD3Response
    {
        [JsonPropertyName("images")]
        public IReadOnlyList<string> Images { get; set; } = new List<string>();
    }
}

